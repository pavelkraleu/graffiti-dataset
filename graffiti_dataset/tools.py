
import cv2
import glob
import random
import plotly
import skimage
import numpy as np
import matplotlib.pyplot as plt
from skimage.segmentation import mark_boundaries
import folium
import plotly.graph_objs as go


def random_background(width, height, background_images_dir):
    """
    Makes image with given size which doesn't contain graffiti

    :param width: Resulting width in pixels
    :param height: Resulting height in pixels
    :param background_images_dir: Directory where to look for images

    """

    negative_images = glob.glob(f'{background_images_dir}/*')

    random.shuffle(negative_images)

    img = cv2.cvtColor(cv2.imread(negative_images[0]),cv2.COLOR_RGB2BGR)

    if min(img.shape[:2]) < min(width, height):
        # Image is smaller than self.target_size. Scale it up

        resize_ratio = min(width, height) / min(img.shape[:2])

    else:
        # Image is larger than self.target_size. Scale it down a little

        resize_ratio = min(width, height) / min(img.shape[:2])
        resize_ratio = random.uniform(resize_ratio, 1.0)

    img = skimage.transform.rescale(img, resize_ratio, multichannel=True, anti_aliasing=True, mode='constant',
                                    preserve_range=True)

    y_range = img.shape[0] - height
    x_range = img.shape[1] - width

    y_skip = random.randint(0, y_range)
    x_skip = random.randint(0, x_range)

    crop_img = img[y_skip:y_skip + height, x_skip:x_skip + width]

    return crop_img

def rgbtohex(rgb_color):
    return '#%02x%02x%02x' % tuple(rgb_color)

def draw_main_colors(image_main_colors, output_path):
    """
    Helper function to generate chart describing color clusters

    :param image_main_colors: Array generated by DatasetSample.main_colors()
    :param output_path: Path where to store the chart
    """

    rgb_colors = np.array(image_main_colors)[:, 1]
    y_pos = np.arange(len(rgb_colors))
    color_percentages = np.array(image_main_colors)[:, 0]

    chart_colors = list(map(rgbtohex, rgb_colors))

    plt.bar(y_pos, color_percentages, align='center', color=chart_colors)
    plt.xticks(y_pos, chart_colors)
    plt.ylabel('% of color in graffiti')
    plt.title('Percentage of colors in graffiti')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig(output_path)

    plt.cla()
    plt.clf()

def draw_hsv_pixels(sample, output_path):

    sample_pixels = sample.graffiti_pixels()
    sample_pixels_hsv = sample.rgb_pixels_to_hsv(sample_pixels).astype(int)

    hsv_hue_values = [0] * 360
    rgb_values = [[] for _ in range(361)]

    for i, pixel in enumerate(sample_pixels_hsv):

        hsv_hue_values[pixel[0]] += 1
        rgb_values[pixel[0]].append(sample_pixels[i])

    for i, rgb_value in enumerate(rgb_values):
        if rgb_value:
            rgb_values[i] = np.mean(rgb_value, axis=0).astype(int)
        else:
            rgb_values[i] = (0,0,0)

    chart_colors = list(map(rgbtohex, rgb_values))

    y_pos = np.arange(360)

    fig = plt.figure(figsize=(10, 5),dpi=200)
    plt.bar(y_pos, hsv_hue_values, align='center', color=chart_colors)
    plt.ylabel('Pixels in graffiti')
    plt.xlabel('Hue')
    plt.title('Pixels in graffiti according Hue value')
    plt.xticks(rotation=45)
    plt.tight_layout()
    plt.savefig(output_path)

    plt.cla()
    plt.clf()

def draw_map(gps_coordinates, output_path):
    """
    Generates map from GPS coordinates of the samples

    :param dataset_samples_paths: List of sample Pickle files
    :param output_path: Output path where to store map in HTML
    """

    map = folium.Map(zoom_start=12,location=list(np.mean(gps_coordinates[:,0:2].astype(float), axis=0)))

    for sample in gps_coordinates:
        folium.Marker(sample[0:2].astype(float), popup=sample[2]).add_to(map)

    map.save(output_path)


def draw_color_cube(dataset_pixels, output_path, colors=None):

    if colors is None:
        colors = dataset_pixels

    color_dots = go.Scatter3d(
        x=dataset_pixels[:,0],
        y=dataset_pixels[:,1],
        z=dataset_pixels[:,2],
        mode='markers',
        marker=dict(
            color=colors,
            size=12,
            symbol='circle',
            line=dict(
                color=colors,
                width=1
            ),
            opacity=0.9
        )
    )

    layout = go.Layout(
        margin=dict(
            l=0,
            r=0,
            b=0,
            t=0
        ),
        scene=dict(
            xaxis=dict(range=[0, 255], nticks=10),
            yaxis=dict(range=[0, 255], nticks=10),
            zaxis=dict(range=[0, 255], nticks=10),
            aspectmode="data"
        )
    )

    fig = go.Figure(data=[color_dots], layout=layout)

    plotly.offline.plot(fig, filename=output_path, auto_open=False)


def draw_super_pixels(super_pixels, image, output_path):

    cv2.imwrite(output_path, mark_boundaries(image, super_pixels) * 255)
